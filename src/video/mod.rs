use crate::memory::Memory;
use minifb::{Window, WindowOptions};

const ZX81_SCREEN_WIDTH: usize = 256; // Screen width
const ZX81_SCREEN_HEIGHT: usize = 192; // Screen height
const ZX81_SCREEN_SF: usize = 3; // Scale factor (to fit modern displays)
const ZX81_DEBUG_PANEL_WIDTH: usize = 192;

// ZX81 Video system
// Character-based display: 32Ã—24 text
// Display generated by CPU in SLOW mode
pub struct Video {
    window: minifb::Window,
    buffer: Vec<u32>,
    width: usize,
    height: usize,
    rev_video: bool,
}

impl Video {
    pub fn new(debug_enabled: bool, rev_video: bool) -> Result<Self, minifb::Error> {
        let width = ZX81_SCREEN_WIDTH * ZX81_SCREEN_SF;
        let height = ZX81_SCREEN_HEIGHT * ZX81_SCREEN_SF;

        let window = Window::new("ZX81 Emulator", width, height, WindowOptions::default())?;
        let buffer = vec![0; width * height];

        if debug_enabled {
            println!("Window size: {} x {}", width, height);
            println!("Buffer size: {} pixels", buffer.len());
        }

        Ok(Self {
            window,
            buffer,
            width,
            height,
            rev_video,
        })
    }
    pub fn render(&mut self, memory: &Memory, rom: &[u8]) {
        let d_file_ptr = memory.read_word(0x400C);

        if d_file_ptr < 0x4000 || d_file_ptr > 0x8000 {
            return;
        }

        let bg_color = if self.rev_video {
            0xFFFFFFFF
        } else {
            0xFF000000
        };
        self.buffer.fill(bg_color);

        // Now render
        let mut addr = d_file_ptr;
        for line in 0..24 {
            for col in 0..32 {
                let char_code = memory.read(addr);
                addr += 1;

                if char_code == 0x76 {
                    break;
                }

                self.render_character(char_code, col, line, rom);
            }

            // Skip to next line - look for the newline
            for _ in 0..33 {
                if memory.read(addr) == 0x76 {
                    addr += 1;
                    break;
                }
                addr += 1;
            }
        }
    }

    fn render_character(&mut self, char_code: u8, col: usize, line: usize, rom: &[u8]) {
        let inverse = (char_code & 0x80) != 0;
        let char_code = char_code & 0x3F;

        if char_code >= 64 {
            // Invalid character
            return;
        }

        let bitmap_addr = 0x1E00 + (char_code as usize * 8);

        if bitmap_addr + 8 > rom.len() {
            return;
        }

        let scale = ZX81_SCREEN_SF;

        // Calculate screen position
        let screen_x = col * 8 * scale;
        let screen_y = line * 8 * scale;

        // Render 8 rows
        for row in 0..8 {
            let bitmap_byte = rom[bitmap_addr + row];

            for bit in 0..8 {
                let pixel = (bitmap_byte >> (7 - bit)) & 1;

                // Apply inverse video if needed
                let pixel = if inverse { 1 - pixel } else { pixel };

                let colour = if self.rev_video {
                    if pixel == 1 { 0xFF000000 } else { 0xFFFFFFFF }
                } else {
                    if pixel == 1 { 0xFFFFFFFF } else { 0xFF000000 }
                };

                for sy in 0..scale {
                    for sx in 0..scale {
                        let x = screen_x + (bit * scale) + sx;
                        let y = screen_y + (row * scale) + sy;
                        let index = y * self.width + x;
                        if index < self.buffer.len() {
                            self.buffer[index] = colour;
                        }
                    }
                }
            }
        }
    }

    pub fn update(&mut self) -> Result<(), minifb::Error> {
        self.window
            .update_with_buffer(&self.buffer, self.width, self.height)?;
        Ok(())
    }

    pub fn is_open(&self) -> bool {
        self.window.is_open()
    }

    pub fn get_keys(&self) -> Vec<minifb::Key> {
        self.window.get_keys()
    }
}
