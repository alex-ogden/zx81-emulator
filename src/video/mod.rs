use crate::memory::Memory;
use minifb::{Window, WindowOptions};

mod character_set;
mod display_file;
mod renderer;

const ZX81_SCREEN_WIDTH: usize = 256; // Screen width
const ZX81_SCREEN_HEIGHT: usize = 192; // Screen height
const ZX81_SCREEN_SF: usize = 2; // Scale factor (to fit modern displays)
const ZX81_DEBUG_PANEL_WIDTH: usize = 192;

// ZX81 Video system
// Character-based display: 32Ã—24 text
// Display generated by CPU in SLOW mode
pub struct Video {
    window: minifb::Window,
    buffer: Vec<u32>,
    width: usize,
    height: usize,
}

impl Video {
    pub fn new(debug_enabled: bool) -> Result<Self, minifb::Error> {
        let width = ZX81_SCREEN_WIDTH * ZX81_SCREEN_SF
            + if debug_enabled {
                ZX81_DEBUG_PANEL_WIDTH
            } else {
                0
            };
        let height = ZX81_SCREEN_HEIGHT * ZX81_SCREEN_SF;
        let window = Window::new("ZX81 Emulator", width, height, WindowOptions::default())?;
        let buffer = vec![0; width * height];
        Ok(Self {
            window,
            buffer,
            width,
            height,
        })
    }

    pub fn render(&mut self, memory: &Memory, rom: &[u8]) {
        let d_file_ptr = memory.read_word(0x400C);

        if d_file_ptr < 0x4000 {
            return;
        }

        self.buffer.fill(0xFF000000);

        // Render 24 lines of characters
        let mut addr = d_file_ptr;
        for line in 0..24 {
            for col in 0..32 {
                let char_code = memory.read(addr);
                addr += 1;

                // Stop when a newline is hit
                if char_code == 0x76 {
                    break;
                }

                // Render this character
                self.render_character(char_code, col, line, rom);
            }

            // Skip past new line
            addr += 1;
        }
    }

    fn render_character(&mut self, char_code: u8, col: usize, line: usize, rom: &[u8]) {
        let char_code = char_code & 0x3F;
        let bitmap_addr = 0x1E00 + (char_code as usize * 8);
        let scale = ZX81_SCREEN_SF;

        // Calculate screen position
        let screen_x = col * 8 * scale;
        let screen_y = line * 8 * scale;

        // Render 8 rows
        for row in 0..8 {
            let bitmap_byte = rom[bitmap_addr + row];

            for bit in 0..8 {
                let pixel = (bitmap_byte >> (7 - bit)) & 1;
                let colour = if pixel == 1 { 0xFFFFFFFF } else { 0xFF000000 }; // White or black

                for sy in 0..scale {
                    for sx in 0..scale {
                        let x = screen_x + (bit * scale) + sx;
                        let y = screen_y + (bit * scale) + sy;
                        let index = y * self.width + x;
                        if index < self.buffer.len() {
                            self.buffer[index] = colour;
                        }
                    }
                }
            }
        }
    }

    pub fn update(&mut self) -> Result<(), minifb::Error> {
        self.window
            .update_with_buffer(&self.buffer, self.width, self.height)?;
        Ok(())
    }

    pub fn is_open(&self) -> bool {
        self.window.is_open()
    }
}
